#version 430
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable

layout( local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

struct ParticleData {
    vec2 pos;
    vec2 vel;
    uint bucketIndex;
    uint gridIndex;
    vec2 density;
};

// Particles come sorted by grid index
layout( std430, binding=3 ) buffer ParticleBuffer
{
    ParticleData particles[];
};

layout( std430, binding=4 ) readonly buffer PrefixSumsBuffer
{
    int prefixSums[];
};

uniform float deltaTime;
uniform float time;

uniform int gridSize;
uniform float mouseX;
uniform float mouseY;
vec2 mouseCoords;

float gravity = -9.82;
float smoothingRadius = 0.8;

float SpikyKernel(float distance, float radius) {
    if (distance >= radius) return 0.0;

    float q = distance - radius;
    return q * q;
    // return q * q * q;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= particles.length()) return;

    mouseCoords = vec2(mouseX, mouseY);

    ParticleData particle = particles[gid];

    //particle.data = vec2(SpikyKernel(length(particle.pos - mouseCoords), smoothingRadius));

    uint gridIndex = particle.gridIndex;

    uint gridRow = gridIndex / gridSize;
    uint gridCol = gridIndex % gridSize;

    // Loop through the 3x3 grid cells
    for (int rowOffset = -1; rowOffset <= 1; rowOffset++) {
        for (int colOffset = -1; colOffset <= 1; colOffset++) {
            int neighborRow = int(gridRow) + rowOffset;
            int neighborCol = int(gridCol) + colOffset;

            // Skip out-of-bounds neighbors
            if (neighborRow < 0 || neighborRow >= int(gridSize) || neighborCol < 0 || neighborCol >= int(gridSize)) {
                continue;
            }

            // Calculate the neighboring cell's grid index
            uint neighborGridIndex = uint(neighborRow) * gridSize + uint(neighborCol);

            //if (neighborGridIndex != gridIndex) continue;
            
            int startIndex = prefixSums[neighborGridIndex];
            int endIndex = prefixSums[neighborGridIndex + 1];

            for (int i = startIndex; i < endIndex; i++) {
                if (i == gid) continue;

                ParticleData other = particles[i];

                particle.density = vec2(SpikyKernel(length(particle.pos - other.pos), smoothingRadius));

                float dx = other.pos.x - particle.pos.x;
                float dy = other.pos.y - particle.pos.y;

                particle.vel += vec2(dx, dy);
            }
        }
    }

    particle.vel = normalize(particle.vel) * 0.01;
    particle.pos += particle.vel * deltaTime;
    
    // Apply gravity
    //particle.acc.y += gravity * deltaTime;
    // particle.vel.y += gravity * deltaTime;
    // particle.pos += particle.vel * deltaTime;

    // // Bounce off the walls
    // if (particle.pos.x < -1.0 || particle.pos.x > 1.0) {
    //     particle.vel.x = -particle.vel.x;
    //     particle.pos.x = clamp(particle.pos.x, -1.0, 1.0);
    // }
    // if (particle.pos.y < -1.0 || particle.pos.y > 1.0) {
    //     particle.vel.y = -particle.vel.y;
    //     particle.pos.y = clamp(particle.pos.y, -1.0, 1.0);
    // }

    particles[gid] = particle;
}